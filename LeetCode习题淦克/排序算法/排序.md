# 一

> 为了方便调试和练习代码我创建了一个gitee仓库
>
> [sort-about: 排序方法总结 (gitee.com)](https://gitee.com/beimengclub/sort-about)

# **O(n^2)级🦽**

## ⏳冒泡排序 bubbleSort

冒泡排序是入门级的算法，但也有一些有趣的玩法。通常来说，冒泡排序有三种写法：

- 一边比较一边向后两两交换，将最大值 / 最小值冒泡到最后一位；
- 经过优化的写法：使用一个变量记录当前轮次的比较是否发生过交换，如果没有发生交换表示已经有序，不再继续排序；
- 进一步优化的写法：除了使用变量记录当前轮次是否发生交换外，再使用一个变量记录上次发生交换的位置，下一轮排序时到达上次交换的位置就停止比较。

```java
public static void swap(int[] nums,int a,int b){
    int temp = nums[a];
    nums[a] = nums[b];
    nums[b] = temp;
}
```



**第一种写法**

```java
public static void sort1(int[] nums){
    for (int i = 0; i < nums.length - 1; i++) {
        for (int j = 0; j < nums.length - 1 - i; j++) {
            if (nums[j] > nums[j+1]){
                swap(nums,j,j+1);
            }
        }
    }
}
```

最外层的 for 循环每经过一轮，剩余数字中的最大值就会被移动到当前轮次的最后一位，中途也会有一些相邻的数字经过交换变得有序。总共比较次数是 (n-1)+(n-2)+(n-3)+…+1(n−1)+(n−2)+(n−3)+…+1。

这种写法相当于相邻的数字两两比较，并且规定：“谁大谁站右边”。经过 n-1n−1 轮，数字就从小到大排序完成了。整个过程看起来就像一个个气泡不断上浮，这也是“冒泡排序法”名字的由来。



**第二种写法**

`比第一种方法稍稍节省一点范围`

```java
public static void sort2(int[] nums){
    boolean noSwap = false;
    for (int i = 0; i < nums.length - 1; i++) {
        if (noSwap)break;
        noSwap = true;
        for (int j = 0; j < nums.length - 1 - i; j++) {
            if (nums[j] > nums[j+1]){
                swap(nums,j,j+1);
                noSwap = false;
            }
        }
    }
}
```

最外层的 for 循环每经过一轮，剩余数字中的最大值仍然是被移动到当前轮次的最后一位。这种写法相对于第一种写法的优点是：如果一轮比较中没有发生过交换，则立即停止排序，因为此时剩余数字一定已经有序了。

看下动图演示：

![冒泡排序优化](https://ccurj.oss-cn-beijing.aliyuncs.com/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E4%BC%98%E5%8C%96.gif)

图中可以看出：

- 第一轮排序将数字 66 移动到最右边；

- 第二轮排序将数字 55 移动到最右边，同时中途将 11 和 22 排了序；
- 第三轮排序时，没有发生交换，表明排序已经完成，不再继续比较。

**第三种写法**

`第三种写法比较少见，它是在第二种写法的基础上进一步优化：`

```java
public static void sort3(int[] nums){
    boolean noSwap = false;
    int lastIndex = nums.length-1;// 最后一个有序元素
    int swappedIndex = -1; // 上次交换位置
    while (!noSwap){
        noSwap = true;
        for (int i=0;i<lastIndex;i++){
            if (nums[i] > nums[i+1]){
                swap(nums,i,i+1);
                noSwap = false;
                swappedIndex = i;
            }
        }
        lastIndex = swappedIndex;
    }
}
```

经过再一次的优化，代码看起来就稍微有点复杂了。最外层的 while 循环每经过一轮，剩余数字中的最大值仍然是被移动到当前轮次的最后一位。

在下一轮比较时，只需比较到上一轮比较中，最后一次发生交换的位置即可。因为后面的所有元素都没有发生过交换，必然已经有序了。

当一轮比较中从头到尾都没有发生过交换，则表示整个列表已经有序，排序完成。

测试：

```java
public void test() {
    int[] arr = new int[]{6, 2, 1, 3, 5, 4};
    bubbleSort(arr);
    // 输出: [1, 2, 3, 4, 5, 6]
    System.out.println(Arrays.toString(arr));
}
```

#### [剑指 Offer 45. 把数组排成最小的数](https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/)

![image-20211127122100061](https://ccurj.oss-cn-beijing.aliyuncs.com/image-20211127122100061.png)

> **冒泡排序**
>
> ```java
> public String minNumber(int[] nums) {
>     // 使用冒泡排序
>     bubbleSort(nums);
>     return Arrays.toString(nums).replaceAll("\\[|]|,|\\s", "");
> }
> 
> public void bubbleSort(int[] nums){
>     // 优化冒泡排序
>     boolean noSwap = false;
>     int lastIndex = nums.length-1;
>     int lastSwap = -1;
>     while(!noSwap){
>         noSwap = true;
>         for(int i=0;i<lastIndex;i++){
>             if((""+nums[i]+nums[i+1]).compareTo(""+nums[i+1]+nums[i]) > 0){
>                 int temp = nums[i];
>                 nums[i] = nums[i+1];
>                 nums[i+1] = temp;
> 
>                 noSwap = false;
>                 lastSwap = i;
>             }
>         }
>         lastSwap = lastSwap;
>     }
> 
> }
> ```
>

<hr style="background:#9cc6ff"></hr>

## ⏳选择排序 selectionSort

选择排序的思想是：双重循环遍历数组，每经过一轮比较，找到最小元素的下标，将其交换至首位。

```java
public static void selectionSort(int[] arr) {
    int minIndex;
    for (int i = 0; i < arr.length - 1; i++) {
        minIndex = i;
        for (int j = i + 1; j < arr.length; j++) {
            if (arr[minIndex] > arr[j]) {
                // 记录最小值的下标
                minIndex = j;
            }
        }
        // 将最小元素交换至首位
        int temp = arr[i];
        arr[i] = arr[minIndex];
        arr[minIndex] = temp;
    }
}
```

`每次选择一个特殊值出来。`

![选择排序](https://ccurj.oss-cn-beijing.aliyuncs.com/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F.gif)

**和冒泡排序的区别**

> 相同之处
>
> - 都是两层循环，时间复杂度都为O(n^2);
> - 都使用有限个数变量，空间复杂度O(1)。
>
> 不同之处
>
> - 冒泡排序在比较过程中不断交换，而选择排序只有当遍历完成后才交换，减少了交换次数。
> - <span style="background: coral;background-image: -webkit-linear-gradient(45deg,#df18bd,#feab3a);-webkit-background-clip: text;-webkit-text-fill-color: transparent;">冒泡排序是稳定的，选择排序是不稳定的。</span>



**排序算法的稳定性**

> 假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，r[i] = r[j]，且 r[i] 在 r[j] 之前，而在排序后的序列中，r[i] 仍在 r[j] 之前，则称这种排序算法是稳定的；否则称为不稳定的。

理解了稳定性的定义后，我们就能分析出：冒泡排序中，只有左边的数字大于右边的数字时才会发生交换，相等的数字之间不会发生交换，所以它是稳定的。

而选择排序中，最小值和首位交换的过程可能会破坏稳定性。比如数列：[2, 2, 1]，在选择排序中第一次进行交换时，原数列中的两个 2 的相对顺序就被改变了，因此，我们说选择排序是不稳定的。

那么排序算法的稳定性有什么意义呢？其实它只在一种情况下有意义：当要排序的内容是一个对象的多个属性，且其原本的顺序存在意义时，如果我们需要在二次排序后保持原有排序的意义，就需要使用到稳定性的算法。

举个例子，如果我们要对一组商品排序，商品存在两个属性：价格和销量。当我们按照价格从高到低排序后，要再按照销量对其排序，这时，如果要保证销量相同的商品仍保持价格从高到低的顺序，就必须使用稳定性算法。

当然，算法的稳定性与具体的实现有关。在修改比较的条件后，稳定性排序算法可能会变成不稳定的。如冒泡算法中，如果将「左边的数大于右边的数，则交换」这个条件修改为「左边的数大于或等于右边的数，则交换」，冒泡算法就变得不稳定了。

同样地，不稳定排序算法也可以经过修改，达到稳定的效果。思考一下，选择排序算法如何实现稳定排序呢？

实现的方式有很多种，这里给出一种最简单的思路：新开一个数组，将每轮找出的最小值依次添加到新数组中，选择排序算法就变成稳定的了。

但如果将寻找最小值的比较条件由arr[minIndex] > arr[j]修改为arr[minIndex] >= arr[j]，即使新开一个数组，选择排序算法依旧是不稳定的。所以分析算法的稳定性时，需要结合具体的实现逻辑才能得出结论，我们通常所说的算法稳定性是基于一般实现而言的。

**二元选择排序**

```java
public static void selectionSort2(int[] arr) {
    int minIndex, maxIndex;
    // i 只需要遍历一半
    for (int i = 0; i < arr.length / 2; i++) {
        minIndex = i;
        maxIndex = i;
        for (int j = i + 1; j < arr.length - i; j++) {
            if (arr[minIndex] > arr[j]) {
                // 记录最小值的下标
                minIndex = j;
            }
            if (arr[maxIndex] < arr[j]) {
                // 记录最大值的下标
                maxIndex = j;
            }
        }
        // 如果 minIndex 和 maxIndex 都相等，那么他们必定都等于 i，且后面的所有数字都与 arr[i] 相等，此时已经排序完成
        if (minIndex == maxIndex) break;
        // 将最小元素交换至首位
        int temp = arr[i];
        arr[i] = arr[minIndex];
        arr[minIndex] = temp;
        // 如果最大值的下标刚好是 i，由于 arr[i] 和 arr[minIndex] 已经交换了，所以这里要更新 maxIndex 的值。
        if (maxIndex == i) maxIndex = minIndex;
        // 将最大元素交换至末尾
        int lastIndex = arr.length - 1 - i;
        temp = arr[lastIndex];
        arr[lastIndex] = arr[maxIndex];
        arr[maxIndex] = temp;
    }
}
```



<hr style="background:#9cc6ff"></hr>

## ⏳插入排序 insertSort





<hr style="background:#9cc6ff"></hr>

## 🧩小结









# **O(nlogn)级🚲**







# **O(n)级🏍️**



