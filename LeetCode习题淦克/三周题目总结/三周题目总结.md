#  题目总结 - 🧷

> 整理习题答案，分析汇总

## 第一周 1|2|3|20|21|22

### [1. 两数之和](https://leetcode-cn.com/problems/two-sum/)

![image-20211008203109561](https://gitee.com/xiao-ai-beimeng/beimeng/raw/master/img/202110082031705.png)

**标签：@数组 @哈希表**

> 思路：在一个数组中寻找**两个**相加和为**目标值**的两个元素下标。
>
> 遍历每个元素，题中说明，只会有一种答案，所以只需要使用每次遍历到的元素，去找另一个元素，有则返回即可
>
> ```java
> public int[] twoSum(int[] nums, int target) {
>     for(int i=0;i<nums.length;i++){
>         for(int j=i+1;j<nums.length;j++){
>             if(target - nums[i] == nums[j])
>                 return new int[]{i,j};
>         }
>     }
> 
>     return null;
> }
> ```
>
> 对于这种遍历方式，时间复杂度为 O(n2)
>
> 优化的方式，使用**@哈希表**。
>
> ```java
> public int[] twoSum(int[] nums, int target) {
>     Map<Integer,Integer> map = new HashMap<>();
> 
>     for(int i=0;i<nums.length;i++){
>         // 现在集合中寻找
>         if(map.containsKey(target - nums[i])){
>             return new int[]{map.get(target - nums[i]),i}; // 先后顺序
>         }else{
>             map.put(nums[i],i);
>         }
>     }
> 
>     return null;
> }
> ```
>
> 

### [2. 两数相加](https://leetcode-cn.com/problems/add-two-numbers/)

![image-20211010194740235](https://gitee.com/xiao-ai-beimeng/beimeng/raw/master/img/202110101947382.png)

**相关标签：@[递归](https://leetcode-cn.com/tag/recursion/problemset/) @[链表](https://leetcode-cn.com/tag/linked-list/problemset/) @[数学](https://leetcode-cn.com/tag/math/problemset/) **

> 思路： 不要忘记进一
>
> ```java
> public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
>     return rrun(l1,l2,0);
> }
> 
> // 递归的方式解决问题
> public ListNode rrun(ListNode l1,ListNode l2, int point){ // 最后一位数表示进一
>     // 定义递归出口
>     if(l1 == null && l2 == null && point == 0)
>         return null;
>     int val = (l1!=null?l1.val:0) + (l2!=null?l2.val:0) + point;
>     int point2 = 0;
>     if(val >= 10){
>         point2 = val/10;
>         val %= 10;
>     }
> 
>     ListNode head = new ListNode(val);
>     head.next = rrun(l1!=null?l1.next:null,l2!=null?l2.next:null,point2);
> 
>     return head;
> }
> ```

### [3. 无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)

![image-20211010201637639](https://gitee.com/xiao-ai-beimeng/beimeng/raw/master/img/202110102016701.png)

**标签：@[哈希表](https://leetcode-cn.com/tag/hash-table/) @[字符串](https://leetcode-cn.com/tag/string/) @[滑动窗口](https://leetcode-cn.com/tag/sliding-window/)**

> 思路：滑动窗口 `滑动窗口问题其实就是枚举法的一种优化形式`
>
> ```java
> public int lengthOfLongestSubstring(String s) {
>  char[] chars = s.toCharArray();
>  String str = "";
>  int len = 0;
>  for(int i=0;i<chars.length;i++){
>      if(str.indexOf("" + chars[i]) == -1){
>          str += chars[i];
>      }else{// 去掉这个值以及之前的所有值
>          if(str.split("" + chars[i]).length >= 2){
>              str = str.split("" + chars[i])[1] + chars[i];
>          }else{
>              str = "" + chars[i];
>          }
>      }
>      if (str.length() > len)
>          len = str.length();
> 
>  }
>  return len;
> }
> ```
>
> **哈希表**
>
> 我们每次要去字符串中寻找一个和当前字符相等的字符的位置
>
> ```java
> public int lengthOfLongestSubstring(String s) {
>     Map<Character,Integer> map = new HashMap<>();
> 
>     int p1=-1,sum=0;
>     char[] chars = s.toCharArray();
>     for(int i=0;i<chars.length;i++){
>         if(map.containsKey(chars[i])&&map.get(chars[i])>=p1){
>             p1 = map.get(chars[i]);
>             map.replace(chars[i],i);
>         }else{
>             map.put(chars[i],i);
>         }
>         sum = Math.max(i-p1,sum);
>     }
> 
>     return sum;
> }
> ```
>
> **数组方式**
>
> ```java
> public int lengthOfLongestSubstring(String s) {
> if(s.length() <= 1)
> return s.length();
> 
> int[] last = new int[128];
> for(int i=0;i<last.length;i++){
> last[i] = -1;
> }
> int start = -1,res = 0;
> for(int i=0;i<s.length();i++){
> int index = s.charAt(i);
> start = Math.max(start,last[index]);
> res = Math.max(res,i-start);
> last[index] = i;
> }
> return res;
> }
> ```

### [20. 有效的括号](https://leetcode-cn.com/problems/valid-parentheses/)

![image-20211011081832439](https://gitee.com/xiao-ai-beimeng/beimeng/raw/master/img/202110110818574.png)

**标签：@[栈](https://leetcode-cn.com/tag/stack/) @[字符串](https://leetcode-cn.com/tag/string/)**

> 思路：使用一个栈
>
> 如果每次遍历的元素是右边的括号，判断栈顶元素和当前元素是否成对，否false 是则出栈，判断下一个
>
> ```java
> public boolean isValid(String s) {
>     Stack<Character> stack = new Stack<>();
>     for (int i = 0; i < s.length(); i++) {
>         char character = s.charAt(i);
>         if (character == ')' || character == '}' || character == ']'){
>             if (stack.isEmpty())
>                 return false; // 如果栈已经为空，直接结束
>             switch (stack.pop()){
>                 case '(':
>                     if (character != ')')
>                         return false;
>                     break;
>                 case '{':
>                     if (character != '}')
>                         return false;
>                     break;
>                 case '[':
>                     if (character != ']')
>                         return false;
>                     break;
>                 default:return false;
>             }
>         }else {
>             stack.push(character);
>         }
>     }
>     return stack.isEmpty();
> }
> ```

### [21. 合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists/)

![image-20211011082538719](https://gitee.com/xiao-ai-beimeng/beimeng/raw/master/img/202110110825802.png)

**标签：@[递归](https://leetcode-cn.com/tag/recursion/) @[链表](https://leetcode-cn.com/tag/linked-list/)**

> 思路：递归
>
> ```java
> public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
> 
>     return run(l1,l2);
> }
> 
> public ListNode run(ListNode l1, ListNode l2){
>     // 递归出口
>     if(l1==null && l2==null)
>         return null;
> 
>     ListNode head; 
>     if((l1!=null?l1.val:101) <= (l2!=null?l2.val:101)){
>         head = l1;
>         l1 = l1!=null?l1.next:null;
>     }else{
>         head = l2;
>         l2 = l2!=null?l2.next:null;
>     }
>     head.next = run(l1,l2);
>     return head;
> }
> ```

### [22. 括号生成](https://leetcode-cn.com/problems/generate-parentheses/)

![image-20211011083905183](https://gitee.com/xiao-ai-beimeng/beimeng/raw/master/img/202110110839245.png)

**标签：@[字符串](https://leetcode-cn.com/tag/string/) @[动态规划](https://leetcode-cn.com/tag/dynamic-programming/) @[回溯](https://leetcode-cn.com/tag/backtracking/)**

> **动态规划**： 找到递推规律即可
> 从题目中获得一个关键的递推式
> f(n) = (a)b a 和 b 的关系是a+b+1=n
> 由这个递推式即可想到动态规划
> 事先知道f(1) = "()"
> 使用一个二维集合保存
>
> ![image-20211011095312931](https://gitee.com/xiao-ai-beimeng/beimeng/raw/master/img/202110110953974.png)
>
> ```java
> List<List<String>> dp;
> public List<String> generateParenthesis(int n) {
>  dp = new ArrayList<>();
>  List<String> one = new ArrayList<>();
>  List<String> two = new ArrayList<>();
>  one.add("");
>  dp.add(one); // 保存f(0) 的值
> 
>  two.add("()");
>  dp.add(two); // 保存f(0) 的值
> 
>  for(int i=2;i<=n;i++){
>      dp.add(f(i));
>  }
>  dp.get(n).sort(new Comparator<String>() {
>      @Override
>      public int compare(String o1, String o2) {
>          int point = 0;
>          while ( point<=o1.length()-1 && o1.charAt(point) == o2.charAt(point)){
>              point++;
>          }
>          if (point > o1.length()-1)
>              return 0;
>          return Character.compare(o1.charAt(point), o2.charAt(point));
>      }
>  });
>  return dp.get(n);
> }
> 
> public List<String> f(int n){
>  //  System.out.print(dp);
>  List<String> ans = new ArrayList<>();
>  n-=1;
>  List<String> a;
>  List<String> b;
>  for(int i=0;i<=n;i++){
>      a = dp.get(n-i);
>      b = dp.get(i);
>      for(String stra:a){
>          for(String strb:b){
>              ans.add("(" + stra + ")" + strb);
>          }
>      }
>  }
>  return ans;
> }
> ```
>
> ![image-20211012155138796](https://gitee.com/xiao-ai-beimeng/beimeng/raw/master/img/202110121551883.png)
>
> **回溯法** 对暴力法的一种剪枝方法 【String 是非引用传递】
>
> ```java
> public List<String> generateParenthesis(int n) {
>     // 回溯法
>     List<String> ans = new ArrayList<>();
> 
>     f(ans,0,0,"",n);
> 
>     return ans;
> }
> 
> public void f(List<String> ans,int left,int right,String str,int n){
>     if(right > left)
>         return ;
>     if(left == right && right == n){
>         ans.add(str);
>         return;
>     }
>     if(left < n)
>         f(ans,left+1,right,str + "(",n);
> 
>     f(ans,left,right+1,str + ")",n);
> }
> ```
>

## 第二周 24|26|27|35|49

### [24. 两两交换链表中的节点](https://leetcode-cn.com/problems/swap-nodes-in-pairs/)

![image-20211011161735337](https://gitee.com/xiao-ai-beimeng/beimeng/raw/master/img/202110111617402.png)

**标签：@[递归](https://leetcode-cn.com/tag/recursion/) @[链表](https://leetcode-cn.com/tag/linked-list/)**

> ```java
> public ListNode swapPairs(ListNode head) {
>     // 保证两个节点
>     if(head==null || head.next==null)
>         return head;
>     ListNode p2 = head.next;
>     head.next = p2.next;
>     p2.next = head;
>     p2.next.next = swapPairs(p2.next.next);
>     return p2;
> }
> ```

### [26. 删除有序数组中的重复项](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/)

![image-20211011162427017](https://gitee.com/xiao-ai-beimeng/beimeng/raw/master/img/202110111624098.png)

**标签：@[数组](https://leetcode-cn.com/tag/array/) @[双指针](https://leetcode-cn.com/tag/two-pointers/)**

> 遍历数组，如果当前值和预定指针位置的值不想同(前提是已经升序排列，交换)
>
> ```java
> public int removeDuplicates(int[] nums) {
>     if(nums.length <= 1){
>         return nums.length;
>     }
>     int p = 0;
>     for(int j = 1;j<nums.length;j++){
>         if(nums[j] != nums[p]){
>             nums[++p] = nums[j];
>         }
>     }
> 
>     return p+1;
> }
> ```

### [27. 移除元素](https://leetcode-cn.com/problems/remove-element/)

![image-20211013102438427](https://gitee.com/xiao-ai-beimeng/beimeng/raw/master/img/202110131024523.png)

**标签: @[数组](https://leetcode-cn.com/tag/array/) @[双指针](https://leetcode-cn.com/tag/two-pointers/)**

> ```java
> public int removeElement(int[] nums, int val) {
>     //int pb = nums.length-1; // point a
>     int tmp;
>     int i=0;
>     for(int pb = nums.length-1;i<=pb;i++){
>         if(nums[pb] == val){
>             pb--;
>             i--;
>             continue;
>         }
>         if(nums[i] == val){
>             tmp = nums[i];
>             nums[i] = nums[pb];
>             nums[pb] = tmp;
>         }
>     }
>     return i;
> }
> ```
>
> 

### [35. 搜索插入位置](https://leetcode-cn.com/problems/search-insert-position/)

![image-20211013103822239](https://gitee.com/xiao-ai-beimeng/beimeng/raw/master/img/202110131038317.png)

**标签： @[数组](https://leetcode-cn.com/tag/array/) @[二分查找](https://leetcode-cn.com/tag/binary-search/)**

> ```java
> public int searchInsert(int[] nums, int target) {
>     if(target <= nums[0])
>         return 0;
>     if(target > nums[nums.length-1])
>         return nums.length;
>     int begin=0;
>     int end = nums.length-1;
>     int mid;
>     while(end - begin > 1){
>         mid = (end-begin)/2 + begin;
>         if(nums[mid] == target)
>             return mid;
>         if(nums[mid] < target)
>             begin = mid;
>         else
>             end = mid;
>     }
>     return end;
> }
> ```

### [49. 字母异位词分组](https://leetcode-cn.com/problems/group-anagrams/)

![image-20211013105336897](https://gitee.com/xiao-ai-beimeng/beimeng/raw/master/img/202110131053969.png)

**标签： @[哈希表](https://leetcode-cn.com/tag/hash-table/) @[字符串](https://leetcode-cn.com/tag/string/) @[排序](https://leetcode-cn.com/tag/sorting/)**

> ```java
> public List<List<String>> groupAnagrams(String[] strs) {
>     Map<String,List<String>> map = new HashMap<>();
> 
>     String sortStr;
>     for(int i=0;i<strs.length;i++){
>         sortStr = sort(strs[i]);
>         if(map.containsKey(sortStr)){
>             map.get(sortStr).add(strs[i]);
>         }
>         else{
>             List<String> list = new ArrayList<>();
>             list.add(strs[i]);
>             map.put(sortStr,list);
>         }
>     }
>     // List<List<String>> ans = new ArrayList<>();
>     // for(List<String> one : map.values()){
>     //     ans.add(one);
>     // }
>     return new ArrayList<List<String>>(map.values());
>     //return ans;
> }
> 
> public String sort(String str){
>     char[] chars = str.toCharArray();
>     Arrays.sort(chars);
>     return new String(chars);
> }
> ```

## 第三周  56|435|452| 🐾



### [56. 合并区间](https://leetcode-cn.com/problems/merge-intervals/)

![image-20211018080802635](https://gitee.com/xiao-ai-beimeng/beimeng/raw/master/img/202110180808704.png)

**标签：[数组](https://leetcode-cn.com/tag/array/) [排序](https://leetcode-cn.com/tag/sorting/)**

> 局部最优解-> 全局最优解
>
> ```java
> public int[][] merge(int[][] intervals) {
>      if(intervals.length <= 1)
>          return intervals;
>        Arrays.sort(intervals,(int[] o1,int[] o2)->{
>            return o1[0]!=o2[0]?o1[0]-o2[0]:o1[1]-o2[1];
>        });
>        List<int[]> list = new ArrayList<>();
>      int begin = intervals[0][0];
>     int end = intervals[0][1]; //结尾
>      for(int i=1;i<intervals.length;i++){
>          if(intervals[i][0] <= end){ // 满足合并条件
>             end = Math.max(end,intervals[i][1]);
>          }else{
>                list.add(new int[]{begin,end});
>                begin = intervals[i][0];
>                end = intervals[i][1];
>            }
>        }
>        list.add(new int[]{begin,end});
>    
>        return list.toArray(new int[list.size()][]);
>    }
>    ```
>    



### [435. 无重叠区间 ⭐](https://leetcode-cn.com/problems/non-overlapping-intervals/)

![image-20211013192201328](https://gitee.com/xiao-ai-beimeng/beimeng/raw/master/img/202110131922402.png)

**标签：@[贪心](https://leetcode-cn.com/tag/greedy/) @[数组](https://leetcode-cn.com/tag/array/) @[动态规划](https://leetcode-cn.com/tag/dynamic-programming/) @[排序](https://leetcode-cn.com/tag/sorting/)**

> **贪心算法**： 所有冲突的区间中我们只保留一个。所以这题就不像想象的那么难。
>
> ```java
> public int eraseOverlapIntervals(int[][] intervals) {
>      Arrays.sort(intervals,(int[] o1,int[] o2)->o1[0]-o2[0]); // 排序。
>      int end = intervals[0][1];
>        int ans = 1;
>        for(int i=0;i<intervals.length;i++){
>            if(intervals[i][0] >= end){
>                ans+=1;
>              end = intervals[i][1];
>          }else
>              end = Math.min(end,intervals[i][1]);
>      }
>      return intervals.length - ans;
>  }
>    ```
>    
>    **动态规划**：
>    
>    

### [452. 用最少数量的箭引爆气球](https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/)

![image-20211018080702558](https://gitee.com/xiao-ai-beimeng/beimeng/raw/master/img/202110180807693.png)

**标签：[贪心](https://leetcode-cn.com/tag/greedy/) [数组](https://leetcode-cn.com/tag/array/) [排序](https://leetcode-cn.com/tag/sorting/)**

> **贪心算法:**  java中int类型的取值范围是 【-2^31 - 2^31-1】但是在排序的过程中,2^31-1 减去 -2^31 会超出int的长度限制。排序的时候比较大小而不是做差可以避免这个问题。
>
> ```java
> public int findMinArrowShots(int[][] points) {
>     Arrays.sort(points,(int[] a,int[] b)->Integer.compare(a[0],b[0]));
>     int end = points[0][1];
>     int ans = 1;
>     for(int i=0;i<points.length;i++){
>         if(points[i][0] > end){
>             ++ans;
>             end = points[i][1];
>         }else
>             end = Math.min(end,points[i][1]);
>     }
>     return ans;
> }
> ```
>
> 



## 第四周  46|53|77|78|57

### [46. 全排列](https://leetcode-cn.com/problems/permutations/)

![image-20211018090614970](https://gitee.com/xiao-ai-beimeng/beimeng/raw/master/img/202110180906056.png)

**标签：[@数组](https://leetcode-cn.com/tag/array/) [@回溯](https://leetcode-cn.com/tag/backtracking/)**

> 探索所有可能，使用回溯算法剪枝 [Java遍历Map集合的四种方式](http://c.biancheng.net/view/6872.html)
>
> ```java
> public List<List<Integer>> permute(int[] nums) { // 使用回溯法
>     List<List<Integer>> list = new ArrayList<>();
>     backTrack(list,new ArrayList<Integer>(),nums);
>     return list;
> }
> 
> public void backTrack(List<List<Integer>> answer,List<Integer> tmp,int[] nums){
>     if(tmp.size() == nums.length){
>         answer.add(tmp);
>     }
> 
>     for(int i=0;i<nums.length;i++){
>         if(!tmp.contains(nums[i])){
>             tmp.add(nums[i]);
>             backTrack(answer,new ArrayList<Integer>(tmp),nums);
>             tmp.remove(tmp.size()-1);
>         }
>     }
> }
> ```
>
> 判断条件优化之后
>
> ```java
> public List<List<Integer>> permute(int[] nums) {// 使用回溯法
>     List<List<Integer>> list = new ArrayList<>();
>     Map<Integer,Boolean> flags = new HashMap<>();
>     for(int i=0;i<nums.length;i++)
>         flags.put(i,false);
>     backTrack(list,new ArrayList<Integer>(),flags,nums);
> 
>     return list;
> }
> 
> public void backTrack(List<List<Integer>> answer,List<Integer> tmp,Map<Integer,Boolean> flags,int[] nums){
>     if(tmp.size() == nums.length){
>         answer.add(tmp);
>     }
> 
>     for(int i=0;i<nums.length;i++){
>         if(!flags.get(i)){
>             flags.replace(i,true);
>             tmp.add(nums[i]);
>             backTrack(answer,new ArrayList<Integer>(tmp),flags,nums);
>             tmp.remove(tmp.size()-1);
>             flags.replace(i,false);
>         }
>     }
> }
> ```
>
> 

### [53. 最大子序和](https://leetcode-cn.com/problems/maximum-subarray/)

![image-20211019111931248](https://gitee.com/xiao-ai-beimeng/beimeng/raw/master/img/202110191436222.png)

**标签：@[数组](https://leetcode-cn.com/tag/array/) @[分治](https://leetcode-cn.com/tag/divide-and-conquer/) @[动态规划](https://leetcode-cn.com/tag/dynamic-programming/)**

> 动态规划：
>
> 每次判断前面和是不是负数。【`🙂】
>
> ```java
> public int maxSubArray(int[] nums) {
>     int dp = nums[0], answer = nums[0];
>     for(int i=1;i<nums.length;i++){
>         dp = Math.max(dp + nums[i],nums[i]);
>         answer = Math.max(answer,dp);
>     }
>     return answer;
> }
> ```
>
> 如果前面的和小于0，那么前面的数字再多也没有意义。

### [77. 组合](https://leetcode-cn.com/problems/combinations/)

![image-20211025150054260](https://gitee.com/xiao-ai-beimeng/beimeng/raw/master/img/202110251500359.png)

**标签： @[数组](https://leetcode-cn.com/tag/array/) @[回溯](https://leetcode-cn.com/tag/backtracking/)**

> 回溯法：
>
> ```java
>  public List<List<Integer>> subsets(int[] nums) {
>         List<List<Integer>> answer = new ArrayList<>();
>         backtrack(answer,new ArrayList<>(),nums,0);
>         return answer;
>  }
> 
> public void backtrack(List<List<Integer>> answer,List<Integer> list,int[] nums,int begin){
>        answer.add(new ArrayList<>(list));
>        for(int i=begin;i<nums.length;i++){
>            list.add(nums[i]);
>            backtrack(answer,list,nums,i+1);
>            list.remove(list.size()-1);
>        }
>    }
>    ```
>    
> 

### [78. 子集](https://leetcode-cn.com/problems/subsets/)

![image-20211102204013632](https://gitee.com/xiao-ai-beimeng/beimeng/raw/master/img/202111022040771.png)

**标签 ：@[位运算](https://leetcode-cn.com/tag/bit-manipulation/) @[数组](https://leetcode-cn.com/tag/array/) @[回溯](https://leetcode-cn.com/tag/backtracking/) **

> ```java
> public List<List<Integer>> subsets(int[] nums) {
>  List<List<Integer>> answer = new ArrayList<>();
>  for(int k=0;k<=nums.length;k++){
>      backtrack(answer,new ArrayList<>(),k,0,nums);
>  }
>  return answer;
> }
> 
> public void backtrack(List<List<Integer>> answer,List<Integer> list,int k,int begin,int[] nums){
>  if(list.size() == k){
>      answer.add(new ArrayList<>(list));
>      return;
>  }
> 
>  for(int i=begin;i<nums.length;i++){
>      list.add(nums[i]);
>      backtrack(answer,list,k,i+1,nums);
>      list.remove(list.size()-1);
>  }
> }
> ```
>
> 但是实际上并不需要循环k，因为在77题的过程中他已经求出所有的子集了
>
> ```java
> public List<List<Integer>> subsets(int[] nums) {
>  List<List<Integer>> answer = new ArrayList<>();
>  backtrack(answer,new ArrayList<>(),nums.length,0,nums);
>  // for(int k=0;k<=nums.length;k++){
>  //     backtrack(answer,new ArrayList<>(),k,0,nums);
>  // }
>  return answer;
> }
> 
> public void backtrack(List<List<Integer>> answer,List<Integer> list,int k,int begin,int[] nums){
>  if(list.size() <= k){
>      answer.add(new ArrayList<>(list));
>  }else
>      return;
> 
>  for(int i=begin;i<nums.length;i++){
>      list.add(nums[i]);
>      backtrack(answer,list,k,i+1,nums);
>      list.remove(list.size()-1);
>  }
> }
> ```
>
> ![image-20211103132435117](https://gitee.com/xiao-ai-beimeng/beimeng/raw/master/img/202111031324618.png)
>
> 

### [57. 插入区间](https://leetcode-cn.com/problems/insert-interval/)

![image-20211103132616954](https://gitee.com/xiao-ai-beimeng/beimeng/raw/master/img/202111031326844.png)

**标签： @[数组](https://leetcode-cn.com/tag/array/) **

> 没有什么方法
>
> ```java
> public int[][] insert(int[][] intervals, int[] newInterval) {
>     if(intervals.length == 0){
>         return new int[][]{newInterval};
>     }
>     List<int[]> answer = new ArrayList<>();
>     int begin = newInterval[0],end = newInterval[1];
>     for(int[] tmp:intervals){
>         if(tmp[1] < begin){
>             answer.add(tmp);
>         }else{
>             if(tmp[0] > end){
>                 answer.add(new int[]{begin,end});
>                 answer.add(tmp);
>                 begin = 10_0001;
>                 continue;
>             }
>             begin = Math.min(tmp[0],begin);
>             end = Math.max(tmp[1],end);
>         }
>     }
>     if(begin != 10_0001){
>         answer.add(new int[]{begin,end});
>     }
>     return answer.toArray(new int[answer.size()][]);
> }
> ```
>
> 

## 第五周 90 | 94 | 102 | 107 | 169

### [90. 子集 II](https://leetcode-cn.com/problems/subsets-ii/)

![image-20211104143357091](https://gitee.com/xiao-ai-beimeng/beimeng/raw/master/img/202111041433553.png)

**标签： @[位运算](https://leetcode-cn.com/tag/bit-manipulation/) @[数组](https://leetcode-cn.com/tag/array/) @[回溯](https://leetcode-cn.com/tag/backtracking/) **

> 本题同78题的不同之处在于新增了重复元素。所以只需要将78的结果集改成set集合即可
>
> ```java
> public List<List<Integer>> subsetsWithDup(int[] nums) {
>     Set<List<Integer>> answerSet = new HashSet<>();
>     backTrack(answerSet,new ArrayList<>(),0,nums);
>     return new ArrayList<>(answerSet);
> }
> 
> public void backTrack(Set<List<Integer>> answerSet,List<Integer> list,int begin,int[] nums){
>     if(list.size() <= nums.length){
>         List<Integer> li = new ArrayList<>(list);
>         li.sort((a,b)->a-b);
>         answerSet.add(li);
>     }else
>         return;
> 
>     for(int i=begin;i<nums.length;i++){
>         list.add(nums[i]);
>         backTrack(answerSet,list,i+1,nums);
>         list.remove(list.size()-1);
>     }
> }
> ```
>
> 

------

**树**

`树 是一种经常用到的数据结构，用来模拟具有树状结构性质的数据集合。
树里的每一个节点有一个值和一个包含所有子节点的列表。从图的观点来看，树也可视为一个拥有N 个节点和N-1 条边的一个有向无环图。
二叉树是一种更为典型的树状结构。如它名字所描述的那样，二叉树是每个节点最多有两个子树的树结构，通常子树被称作“左子树”和“右子树”。`

[❗❗二叉树 👉](https://leetcode-cn.com/leetbook/read/data-structure-binary-tree/xe4u51/)

### [94. 二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)

![image-20211104145213390](https://gitee.com/xiao-ai-beimeng/beimeng/raw/master/img/202111041452804.png)

**标签： @[栈](https://leetcode-cn.com/tag/stack/) @[树](https://leetcode-cn.com/tag/tree/) @[深度优先搜索](https://leetcode-cn.com/tag/depth-first-search/) @[二叉树](https://leetcode-cn.com/tag/binary-tree/)**

> 递归法：
>
> ```java
> public List<Integer> inorderTraversal(TreeNode root) {
>  List<Integer> answer = new ArrayList<>();
>  if(root != null)
>      run(answer,root);
>  return answer;
> }
> 
> public void run(List<Integer> answer,TreeNode root){
>  if(root.left != null)
>      run(answer,root.left);
>  answer.add(root.val);
>  if(root.right != null)
>      run(answer,root.right);
> }
> ```
>
> **进阶：递归算法很简单，你可以通过迭代算法完成吗？**
>
> `递归和迭代的区别. 递归和迭代都是循环的一种。. 递归是重复调用函数自身实现循环。. 迭代是函数内某段代码实现循环。. 其中，迭代与普通循环的区别是：迭代时，循环代码中参与运算的变量同时是保存结果的变量，当前保存的结果作为下一次循环计算的初始值。. 递归循环中，遇到满足终止条件的情况时逐层返回来结束。. 迭代则使用计数器结束循环。. 当然很多情况都是多种循环混合采用，这要根据具体需求。`
>
> ![image-20211105102622870](https://gitee.com/xiao-ai-beimeng/beimeng/raw/master/img/202111051026146.png)
>
> ```java
> public List<Integer> inorderTraversal(TreeNode root) {
>     List<Integer> answer = new ArrayList<>();
>     Stack<TreeNode> stack = new Stack<>();
>     TreeNode point = root;
> 
>     while(point != null || !stack.isEmpty()){
>         if(point != null){ // 如果当前节点不空，前往左子树
>             stack.push(point);
>             point = point.left;
>         }else{
>             point = stack.pop();
>             answer.add(point.val);
>             point = point.right;
>         }
>     }
>     return answer;
> }
> ```
>
> 

### [145. 二叉树的后序遍历](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/)

![image-20211105112711724](https://gitee.com/xiao-ai-beimeng/beimeng/raw/master/img/202111051127895.png)

**标签; @[栈](https://leetcode-cn.com/tag/stack/) @[树](https://leetcode-cn.com/tag/tree/) @[深度优先搜索](https://leetcode-cn.com/tag/depth-first-search/) @[二叉树](https://leetcode-cn.com/tag/binary-tree/) **

> 迭代法：
>
> ```java
> public List<Integer> postorderTraversal(TreeNode root) {
>     // 二叉树的后序遍历 - [左 右 根]
>     List<Integer> answer = new ArrayList<>();
>     run(answer,root);
>     return answer;
> }
> 
> public void run(List<Integer> answer,TreeNode root){
>     if(root == null)
>         return ;
>     run(answer,root.left);
>     run(answer,root.right);
>     answer.add(root.val);
> }
> ```
>
> 非递归迭代法：
>
> ```java
> public List<Integer> postorderTraversal(TreeNode root) {
>     // 二叉树的后序遍历 - [左 右 根] 非递归，消除递归 [根 - 右 - 左]
>     List<Integer> answer = new ArrayList<>();
>     Stack<TreeNode> stack = new Stack<>();
>     TreeNode point = root;
>     while(point != null || !stack.isEmpty()){
>         if(point != null){
>             answer.add(point.val);
>             stack.push(point);
>             point = point.right;
>         }else{
>             point = stack.pop();
>             point = point.left;
>         }
>     }
>     Collections.reverse(answer);
>     return answer;
> }
> ```
>
> 

### [102. 二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)

![image-20211104151524242](https://gitee.com/xiao-ai-beimeng/beimeng/raw/master/img/202111041515677.png)

**标签：@[树](https://leetcode-cn.com/tag/tree/) @[广度优先搜索](https://leetcode-cn.com/tag/breadth-first-search/) @[二叉树](https://leetcode-cn.com/tag/binary-tree/) **

> 二叉树的广度优先遍历 借助队列 【需要维护一个层级关系】
>
> ```java
> public List<List<Integer>> levelOrder(TreeNode root) {
>     Queue<TreeNode> queue = new LinkedList<>(); // 层序遍历。
>     List<List<Integer>> answer = new ArrayList<>();
>     if(root == null)
>         return answer;
>     queue.offer(root);
>     while(!queue.isEmpty()){ // 判断队列长度
>         int currentQueueLength = queue.size();
>         List<Integer> list = new ArrayList<>();
>         for(int i=0;i<currentQueueLength;i++){
>             TreeNode point = queue.poll();
>             list.add(point.val);
>             if(point.left != null)
>                 queue.offer(point.left);
>             if(point.right != null)
>                 queue.offer(point.right);
>         }
>         answer.add(list);
>     }
>     return answer;
> }
> ```
>
> 

### [107. 二叉树的层序遍历 II](https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/)

![image-20211106112843862](https://gitee.com/xiao-ai-beimeng/beimeng/raw/master/img/202111061128523.png)

> ```java
> public List<List<Integer>> levelOrderBottom(TreeNode root) {
>     LinkedList<List<Integer>> answer = new LinkedList<>();
>     Queue<TreeNode> queue = new LinkedList<>();
>     if(root == null)
>         return answer;
>     queue.add(root);
>     TreeNode point = root;
> 
>     while(!queue.isEmpty()){
>         int length = queue.size();
>         List<Integer> list = new ArrayList<>();
>         for(int i=0;i<length;i++){
>             point = queue.poll();
>             list.add(point.val);
>             if(point.left!=null)
>                 queue.add(point.left);
>             if(point.right!=null)
>                 queue.add(point.right);
>         }
>         answer.addFirst(list);
>     }
> 
> 
>     return answer;
> }
> ```

### [169. 多数元素](https://leetcode-cn.com/problems/majority-element/)

![image-20211107121455399](https://gitee.com/xiao-ai-beimeng/beimeng/raw/master/img/202111071214111.png)

**标签：@[数组](https://leetcode-cn.com/tag/array/)@[哈希表](https://leetcode-cn.com/tag/hash-table/)@[分治](https://leetcode-cn.com/tag/divide-and-conquer/)@[计数](https://leetcode-cn.com/tag/counting/)@[排序](https://leetcode-cn.com/tag/sorting/)**

> **哈希表**
>
> ```java
> public int majorityElement(int[] nums) {
>     Map<Integer,Integer> map = new HashMap<>();
>     for(int num : nums){
>         if(map.containsKey(num)){
>             int sum = map.get(num)+1;
>             map.replace(num,sum);
>         }else{
>             map.put(num,1);
>         }
>         if(map.get(num) > nums.length/2)
>             return num;
>     }
>     return 0;
> }
> ```
>
> **摩尔投票法**
>
> `在一个装满黑白两种球的池子中，两两对比，如果不同则消除，相同则保留。最后剩下的一定是最多的。`
>
> ```java
> public int majorityElement(int[] nums) {
>     int currentNum = 0,count = 0;
>     for(int num:nums){
>         if(count == 0){
>             currentNum = num;
>             count=1;
>         }else{
>             // currentNum==num?count++:count--;
>             if(currentNum==num)
>                 count++;
>             else
>                 count--;
>         }
>     }
>     return currentNum;
> }
> ```
>
> **随缘法**
>
> `在管子里的蛇，身体长于管子的一半的话，砍中间就肯定能砍到`
>
> ```python
> class Solution:
>     def majorityElement(self, nums: List[int]) -> int:
>         return sorted(nums)[len(nums) // 2]
> ```

## 第六周 200 | 206 | 209 | 215 | 217

### [200. 岛屿数量](https://leetcode-cn.com/problems/number-of-islands/)

![image-20211112123252813](https://gitee.com/xiao-ai-beimeng/beimeng/raw/master/img/202111121232181.png)

**标签：@[深度优先搜索](https://leetcode-cn.com/tag/depth-first-search/)@[广度优先搜索](https://leetcode-cn.com/tag/breadth-first-search/)@[并查集](https://leetcode-cn.com/tag/union-find/)@[数组](https://leetcode-cn.com/tag/array/)@[矩阵](https://leetcode-cn.com/tag/matrix/)**

> **方法一：深度优先遍历**
>
> `我们可以将二维网格看成一个无向图，竖直或水平相邻的 11 之间有边相连。为了求出岛屿的数量，我们可以扫描整个二维网格。如果一个位置为 11，则以其为起始节点开始进行深度优先搜索。在深度优先搜索的过程中，每个搜索到的 11 都会被重新标记为 0。`
>
> **方法二：广度优先遍历**
>
> `同样的，我们也可以使用广度优先遍历代替深度优先遍历`
>
> ```java
> ```
>
> 
>
> **方法三：并查集**
>
> `同样地，我们也可以使用并查集代替搜索。为了求出岛屿的数量，我们可以扫描整个二维网格。如果一个位置为 11，则将其与相邻四个方向上的 11 在并查集中进行合并。最终岛屿的数量就是并查集中连通分量的数目。`
>
> ```java
> ```
>
> 

