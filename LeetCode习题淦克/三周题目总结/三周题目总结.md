# 题目总结 - 🧷

> 整理习题答案，分析汇总

## 第一周 1|2|3|20|21|22

### [1. 两数之和](https://leetcode-cn.com/problems/two-sum/)

![image-20211008203109561](https://gitee.com/xiao-ai-beimeng/beimeng/raw/master/img/202110082031705.png)

**标签：@数组 @哈希表**

> 思路：在一个数组中寻找**两个**相加和为**目标值**的两个元素下标。
>
> 遍历每个元素，题中说明，只会有一种答案，所以只需要使用每次遍历到的元素，去找另一个元素，有则返回即可
>
> ```java
> public int[] twoSum(int[] nums, int target) {
>     for(int i=0;i<nums.length;i++){
>         for(int j=i+1;j<nums.length;j++){
>             if(target - nums[i] == nums[j])
>                 return new int[]{i,j};
>         }
>     }
> 
>     return null;
> }
> ```
>
> 对于这种遍历方式，时间复杂度为 O(n2)
>
> 优化的方式，使用**@哈希表**。
>
> ```java
> public int[] twoSum(int[] nums, int target) {
>     Map<Integer,Integer> map = new HashMap<>();
> 
>     for(int i=0;i<nums.length;i++){
>         // 现在集合中寻找
>         if(map.containsKey(target - nums[i])){
>             return new int[]{map.get(target - nums[i]),i}; // 先后顺序
>         }else{
>             map.put(nums[i],i);
>         }
>     }
> 
>     return null;
> }
> ```
>
> 

### [2. 两数相加](https://leetcode-cn.com/problems/add-two-numbers/)

![image-20211010194740235](https://gitee.com/xiao-ai-beimeng/beimeng/raw/master/img/202110101947382.png)

**相关标签：@[递归](https://leetcode-cn.com/tag/recursion/problemset/) @[链表](https://leetcode-cn.com/tag/linked-list/problemset/) @[数学](https://leetcode-cn.com/tag/math/problemset/) **

> 思路： 不要忘记进一
>
> ```java
> public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
>     return rrun(l1,l2,0);
> }
> 
> // 递归的方式解决问题
> public ListNode rrun(ListNode l1,ListNode l2, int point){ // 最后一位数表示进一
>     // 定义递归出口
>     if(l1 == null && l2 == null && point == 0)
>         return null;
>     int val = (l1!=null?l1.val:0) + (l2!=null?l2.val:0) + point;
>     int point2 = 0;
>     if(val >= 10){
>         point2 = val/10;
>         val %= 10;
>     }
> 
>     ListNode head = new ListNode(val);
>     head.next = rrun(l1!=null?l1.next:null,l2!=null?l2.next:null,point2);
> 
>     return head;
> }
> ```

### [3. 无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)

![image-20211010201637639](https://gitee.com/xiao-ai-beimeng/beimeng/raw/master/img/202110102016701.png)

**标签：@[哈希表](https://leetcode-cn.com/tag/hash-table/) @[字符串](https://leetcode-cn.com/tag/string/) @[滑动窗口](https://leetcode-cn.com/tag/sliding-window/)**

> 思路：滑动窗口 `滑动窗口问题其实就是枚举法的一种优化形式`
>
> ```java
> public int lengthOfLongestSubstring(String s) {
>  char[] chars = s.toCharArray();
>  String str = "";
>  int len = 0;
>  for(int i=0;i<chars.length;i++){
>      if(str.indexOf("" + chars[i]) == -1){
>          str += chars[i];
>      }else{// 去掉这个值以及之前的所有值
>          if(str.split("" + chars[i]).length >= 2){
>              str = str.split("" + chars[i])[1] + chars[i];
>          }else{
>              str = "" + chars[i];
>          }
>      }
>      if (str.length() > len)
>          len = str.length();
> 
>  }
>  return len;
> }
> ```
>
> **哈希表**
>
> 我们每次要去字符串中寻找一个和当前字符相等的字符的位置
>
> ```java
> public int lengthOfLongestSubstring(String s) {
>     Map<Character,Integer> map = new HashMap<>();
> 
>     int p1=-1,sum=0;
>     char[] chars = s.toCharArray();
>     for(int i=0;i<chars.length;i++){
>         if(map.containsKey(chars[i])&&map.get(chars[i])>=p1){
>             p1 = map.get(chars[i]);
>             map.replace(chars[i],i);
>         }else{
>             map.put(chars[i],i);
>         }
>         sum = Math.max(i-p1,sum);
>     }
> 
>     return sum;
> }
> ```
>
> **数组方式**
>
> ```java
> public int lengthOfLongestSubstring(String s) {
> if(s.length() <= 1)
> return s.length();
> 
> int[] last = new int[128];
> for(int i=0;i<last.length;i++){
> last[i] = -1;
> }
> int start = -1,res = 0;
> for(int i=0;i<s.length();i++){
> int index = s.charAt(i);
> start = Math.max(start,last[index]);
> res = Math.max(res,i-start);
> last[index] = i;
> }
> return res;
> }
> ```

### [20. 有效的括号](https://leetcode-cn.com/problems/valid-parentheses/)

![image-20211011081832439](https://gitee.com/xiao-ai-beimeng/beimeng/raw/master/img/202110110818574.png)

**标签：@[栈](https://leetcode-cn.com/tag/stack/) @[字符串](https://leetcode-cn.com/tag/string/)**

> 思路：使用一个栈
>
> 如果每次遍历的元素是右边的括号，判断栈顶元素和当前元素是否成对，否false 是则出栈，判断下一个
>
> ```java
> public boolean isValid(String s) {
>     Stack<Character> stack = new Stack<>();
>     for (int i = 0; i < s.length(); i++) {
>         char character = s.charAt(i);
>         if (character == ')' || character == '}' || character == ']'){
>             if (stack.isEmpty())
>                 return false; // 如果栈已经为空，直接结束
>             switch (stack.pop()){
>                 case '(':
>                     if (character != ')')
>                         return false;
>                     break;
>                 case '{':
>                     if (character != '}')
>                         return false;
>                     break;
>                 case '[':
>                     if (character != ']')
>                         return false;
>                     break;
>                 default:return false;
>             }
>         }else {
>             stack.push(character);
>         }
>     }
>     return stack.isEmpty();
> }
> ```

### [21. 合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists/)

![image-20211011082538719](https://gitee.com/xiao-ai-beimeng/beimeng/raw/master/img/202110110825802.png)

**标签：@[递归](https://leetcode-cn.com/tag/recursion/) @[链表](https://leetcode-cn.com/tag/linked-list/)**

> 思路：递归
>
> ```java
> public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
> 
>     return run(l1,l2);
> }
> 
> public ListNode run(ListNode l1, ListNode l2){
>     // 递归出口
>     if(l1==null && l2==null)
>         return null;
> 
>     ListNode head; 
>     if((l1!=null?l1.val:101) <= (l2!=null?l2.val:101)){
>         head = l1;
>         l1 = l1!=null?l1.next:null;
>     }else{
>         head = l2;
>         l2 = l2!=null?l2.next:null;
>     }
>     head.next = run(l1,l2);
>     return head;
> }
> ```

### [22. 括号生成](https://leetcode-cn.com/problems/generate-parentheses/)

![image-20211011083905183](https://gitee.com/xiao-ai-beimeng/beimeng/raw/master/img/202110110839245.png)

**标签：@[字符串](https://leetcode-cn.com/tag/string/) @[动态规划](https://leetcode-cn.com/tag/dynamic-programming/) @[回溯](https://leetcode-cn.com/tag/backtracking/)**

> **动态规划**： 找到递推规律即可
> 从题目中获得一个关键的递推式
> f(n) = (a)b a 和 b 的关系是a+b+1=n
> 由这个递推式即可想到动态规划
> 事先知道f(1) = "()"
> 使用一个二维集合保存
>
> ![image-20211011095312931](https://gitee.com/xiao-ai-beimeng/beimeng/raw/master/img/202110110953974.png)
>
> ```java
> List<List<String>> dp;
> public List<String> generateParenthesis(int n) {
>  dp = new ArrayList<>();
>  List<String> one = new ArrayList<>();
>  List<String> two = new ArrayList<>();
>  one.add("");
>  dp.add(one); // 保存f(0) 的值
> 
>  two.add("()");
>  dp.add(two); // 保存f(0) 的值
> 
>  for(int i=2;i<=n;i++){
>      dp.add(f(i));
>  }
>  dp.get(n).sort(new Comparator<String>() {
>      @Override
>      public int compare(String o1, String o2) {
>          int point = 0;
>          while ( point<=o1.length()-1 && o1.charAt(point) == o2.charAt(point)){
>              point++;
>          }
>          if (point > o1.length()-1)
>              return 0;
>          return Character.compare(o1.charAt(point), o2.charAt(point));
>      }
>  });
>  return dp.get(n);
> }
> 
> public List<String> f(int n){
>  //  System.out.print(dp);
>  List<String> ans = new ArrayList<>();
>  n-=1;
>  List<String> a;
>  List<String> b;
>  for(int i=0;i<=n;i++){
>      a = dp.get(n-i);
>      b = dp.get(i);
>      for(String stra:a){
>          for(String strb:b){
>              ans.add("(" + stra + ")" + strb);
>          }
>      }
>  }
>  return ans;
> }
> ```
>
> ![image-20211012155138796](https://gitee.com/xiao-ai-beimeng/beimeng/raw/master/img/202110121551883.png)
>
> **回溯法** 对暴力法的一种剪枝方法 【String 是非引用传递】
>
> ```java
> public List<String> generateParenthesis(int n) {
>     // 回溯法
>     List<String> ans = new ArrayList<>();
> 
>     f(ans,0,0,"",n);
> 
>     return ans;
> }
> 
> public void f(List<String> ans,int left,int right,String str,int n){
>     if(right > left)
>         return ;
>     if(left == right && right == n){
>         ans.add(str);
>         return;
>     }
>     if(left < n)
>         f(ans,left+1,right,str + "(",n);
> 
>     f(ans,left,right+1,str + ")",n);
> }
> ```
>

## 第二周 24|26|27|35|49

### [24. 两两交换链表中的节点](https://leetcode-cn.com/problems/swap-nodes-in-pairs/)

![image-20211011161735337](https://gitee.com/xiao-ai-beimeng/beimeng/raw/master/img/202110111617402.png)

**标签：@[递归](https://leetcode-cn.com/tag/recursion/) @[链表](https://leetcode-cn.com/tag/linked-list/)**

> ```java
> public ListNode swapPairs(ListNode head) {
>     // 保证两个节点
>     if(head==null || head.next==null)
>         return head;
>     ListNode p2 = head.next;
>     head.next = p2.next;
>     p2.next = head;
>     p2.next.next = swapPairs(p2.next.next);
>     return p2;
> }
> ```

### [26. 删除有序数组中的重复项](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/)

![image-20211011162427017](https://gitee.com/xiao-ai-beimeng/beimeng/raw/master/img/202110111624098.png)

**标签：@[数组](https://leetcode-cn.com/tag/array/) @[双指针](https://leetcode-cn.com/tag/two-pointers/)**

> 找到不重复项，移到前面
>
> ```java
> public int removeDuplicates(int[] nums) {
>  if(nums.length <= 1)
>      return nums.length;
>  int len = 1;
>  int num = nums[0];
> 
>  for(int i=1;i<nums.length;i++){
>      if(nums[i] > num){
>          len++;
>          num = nums[i];
>      }else{
>          for(int j=i+1;j<nums.length;j++){
>              if(nums[j] > num){
>                  int tmp = nums[j];
>                  nums[j] = nums[i];
>                  nums[i] = tmp;
>                  num = nums[i];
>                  len++;
>                  break;
>              }
> 
>          }
>      }
>  }
> 
>  return len;
> }
> ```
>
> 优化
>
> ```java
> public int removeDuplicates(int[] nums) {
>  if(nums.length <= 1)
>      return nums.length;
>  int len = 1;
>  int num = nums[0];
>  int j = 2;
>  int tmp;
>  for(int i=1;i<nums.length;i++){
>      if(nums[i] > num){
>          len++;
>          num = nums[i];
>      }else{
>          while(j<nums.length){
>              if(nums[j] > num){
>                  tmp = nums[j];
>                  nums[j] = nums[i];
>                  nums[i] = tmp;
>                  num = nums[i];
>                  len++;
>                  j++;
>                  break;
>              }
>              j++;
>          }
>      }
>  }
> 
>  return len;
> }
> ```
> ```java
> class Solution {
> public int removeDuplicates(int[] nums) {
>     if(nums.length==0){
>         return 0;
>     }
>     int  i=0;
>     for(int j=0;j<nums.length;j++){
>        if(nums[i]!=nums[j]){
>            i++;
>            nums[i]=nums[j];
>          }
>       }
>        return i+1;
>     }
> }
> ```
>
> ![image-20211013102410283](https://gitee.com/xiao-ai-beimeng/beimeng/raw/master/img/202110131024398.png)

### [27. 移除元素](https://leetcode-cn.com/problems/remove-element/)

![image-20211013102438427](https://gitee.com/xiao-ai-beimeng/beimeng/raw/master/img/202110131024523.png)

**标签: @[数组](https://leetcode-cn.com/tag/array/) @[双指针](https://leetcode-cn.com/tag/two-pointers/)**

> ```java
> public int removeElement(int[] nums, int val) {
>     //int pb = nums.length-1; // point a
>     int tmp;
>     int i=0;
>     for(int pb = nums.length-1;i<=pb;i++){
>         if(nums[pb] == val){
>             pb--;
>             i--;
>             continue;
>         }
>         if(nums[i] == val){
>             tmp = nums[i];
>             nums[i] = nums[pb];
>             nums[pb] = tmp;
>         }
>     }
>     return i;
> }
> ```
>
> 

### [35. 搜索插入位置](https://leetcode-cn.com/problems/search-insert-position/)

![image-20211013103822239](https://gitee.com/xiao-ai-beimeng/beimeng/raw/master/img/202110131038317.png)

**标签： @[数组](https://leetcode-cn.com/tag/array/) @[二分查找](https://leetcode-cn.com/tag/binary-search/)**

> ```java
> public int searchInsert(int[] nums, int target) {
>     if(target <= nums[0])
>         return 0;
>     if(target > nums[nums.length-1])
>         return nums.length;
>     int begin=0;
>     int end = nums.length-1;
>     int mid;
>     while(end - begin > 1){
>         mid = (end-begin)/2 + begin;
>         if(nums[mid] == target)
>             return mid;
>         if(nums[mid] < target)
>             begin = mid;
>         else
>             end = mid;
>     }
>     return end;
> }
> ```

### [49. 字母异位词分组](https://leetcode-cn.com/problems/group-anagrams/)

![image-20211013105336897](https://gitee.com/xiao-ai-beimeng/beimeng/raw/master/img/202110131053969.png)

**标签： @[哈希表](https://leetcode-cn.com/tag/hash-table/) @[字符串](https://leetcode-cn.com/tag/string/) @[排序](https://leetcode-cn.com/tag/sorting/)**

> ```java
> public List<List<String>> groupAnagrams(String[] strs) {
>     Map<String,List<String>> map = new HashMap<>();
> 
>     String sortStr;
>     for(int i=0;i<strs.length;i++){
>         sortStr = sort(strs[i]);
>         if(map.containsKey(sortStr)){
>             map.get(sortStr).add(strs[i]);
>         }
>         else{
>             List<String> list = new ArrayList<>();
>             list.add(strs[i]);
>             map.put(sortStr,list);
>         }
>     }
>     // List<List<String>> ans = new ArrayList<>();
>     // for(List<String> one : map.values()){
>     //     ans.add(one);
>     // }
>     return new ArrayList<List<String>>(map.values());
>     //return ans;
> }
> 
> public String sort(String str){
>     char[] chars = str.toCharArray();
>     Arrays.sort(chars);
>     return new String(chars);
> }
> ```

## 第三周  56|435|452|



### [56. 合并区间](https://leetcode-cn.com/problems/merge-intervals/)

![image-20211018080802635](https://gitee.com/xiao-ai-beimeng/beimeng/raw/master/img/202110180808704.png)

**标签：[数组](https://leetcode-cn.com/tag/array/) [排序](https://leetcode-cn.com/tag/sorting/)**

> 局部最优解-> 全局最优解
>
> ```java
> public int[][] merge(int[][] intervals) {
>     // 数组排序
>     Arrays.sort(intervals, new Comparator<int[]>(){
>         public int compare(int[] o1,int[] o2){
>             return o1[0] > o2[0] ? 1 : o1[0] < o2[0] ? -1: Integer.compare(o1[1],o2[1]);
>         }
>     });
> 
>     // 判断下一个数组和当前的数组是否重叠。
>     List<int[]> list = new ArrayList<>();
> 
>     for(int i=0;i<intervals.length;i++){
>         int end = intervals[i][1];
>         int p = i+1;
>         if(p < intervals.length){
>             while(p < intervals.length && intervals[p][0] <= end){
>                 end = Math.max(intervals[p][1],end);
>                 p++;
>             }
>             // 两种情况，p超长了，或者p的位置不符合要求了
>             p--;
>         }else
>             p = i;
>         list.add(new int[]{intervals[i][0],end});
>         i = p;
>     }
> 
>     return list.toArray(new int[list.size()][]);
> }
> ```
>
> 



### [435. 无重叠区间 ⭐](https://leetcode-cn.com/problems/non-overlapping-intervals/)

![image-20211013192201328](https://gitee.com/xiao-ai-beimeng/beimeng/raw/master/img/202110131922402.png)

**标签：@[贪心](https://leetcode-cn.com/tag/greedy/) @[数组](https://leetcode-cn.com/tag/array/) @[动态规划](https://leetcode-cn.com/tag/dynamic-programming/) @[排序](https://leetcode-cn.com/tag/sorting/)**

> 贪心算法：
>
> ```java
> public int eraseOverlapIntervals(int[][] intervals) {
>  // 先排序
>  Arrays.sort(intervals,new Comparator<int[]>(){
>      @Override
>      public int compare(int[] o1, int[] o2) {
>          return Integer.compare(o1[0],o2[0]);
>      }
>  });
>  int ans = 0;// 保留的个数
>  int j = 0;
>  int endP ;
>  // 贪心算法，每次保存其中的最短项
>  for(int i=0;i<intervals.length;i++){// 每次都假设保留当前数组
>      endP = i;
>      j = i+1;
>      while(j<intervals.length && intervals[j][0] < intervals[i][1]){
>          if(intervals[j][1] < intervals[endP][1] ){ // 包含关系，保留当前数组
>              endP = j;
>          }
>          j+=1;
>      }
>      if(endP!=i){
>          i=endP-1;
>      }else{
>          i = j-1;
>          ans+=1;
>      }
>  }
>  return intervals.length - ans;
> }
> ```
>
> 动态规划
>
> ```java
> 
> ```
>
> 

### [452. 用最少数量的箭引爆气球](https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/)

![image-20211018080702558](https://gitee.com/xiao-ai-beimeng/beimeng/raw/master/img/202110180807693.png)

**标签：[贪心](https://leetcode-cn.com/tag/greedy/) [数组](https://leetcode-cn.com/tag/array/) [排序](https://leetcode-cn.com/tag/sorting/)**

> 贪心算法：不太好思考的一道题：
>
> 



## 第四周  46|53|77|78|57❗

### [46. 全排列](https://leetcode-cn.com/problems/permutations/)

![image-20211018090614970](https://gitee.com/xiao-ai-beimeng/beimeng/raw/master/img/202110180906056.png)

**标签：[@数组](https://leetcode-cn.com/tag/array/) [@回溯](https://leetcode-cn.com/tag/backtracking/)**

> 探索所有可能，使用回溯算法剪枝 [Java遍历Map集合的四种方式](http://c.biancheng.net/view/6872.html)
>
> ```java
>  public List<List<Integer>> permute(int[] nums) {
>      // 使用回溯法
>      List<List<Integer>> result = new ArrayList<>();
>      List<Boolean> flags = new ArrayList<>();
>      for(int a: nums){
>          flags.add(false);
>      }
>      backtrack(result,flags,new ArrayList<Integer>(),nums);
> 
>      return result;
>  }
> 
> public void backtrack(List<List<Integer>> result,List<Boolean> flags,List<Integer> list,int[] nums){
>     // 递归出口
>     if(list.size() == flags.size()){
>         result.add(list);
>         return;
>     }
> 
>     for(int i = 0; i<flags.size();i++){
>         if(!flags.get(i)){
>             flags.set(i,true);
>             list.add(nums[i]);
>             List<Integer> list2 = new ArrayList<>(list);
>             backtrack(result,flags,list2,nums);
>             list.remove(list.size()-1);
>             flags.set(i,false);
>         }
>     }
> }
> ```

### [53. 最大子序和](https://leetcode-cn.com/problems/maximum-subarray/)

![image-20211019111931248](https://gitee.com/xiao-ai-beimeng/beimeng/raw/master/img/202110191436222.png)

**标签：@[数组](https://leetcode-cn.com/tag/array/) @[分治](https://leetcode-cn.com/tag/divide-and-conquer/) @[动态规划](https://leetcode-cn.com/tag/dynamic-programming/)**

> 动态规划：
>
> 每次有两个选择，要么是上一个最大子数组，要么是以当前元素为起点的子数组 
>
> 动态规划递推公式 f(n) = nums[n] | f(n-1) + nums[n]
>
> ```java
> public int maxSubArray(int[] nums) {
>  if(nums.length == 1)
>      return nums[0];
>  int dp = nums[0], answer = nums[0];
>  for(int i=1;i<nums.length;i++){
>      dp = Math.max(dp+ nums[i], nums[i]);
>      answer = Math.max(answer,dp);
>  }
>  return answer;
> }
> ```
>
> 分治法：
>

### [77. 组合](https://leetcode-cn.com/problems/combinations/)

![image-20211025150054260](https://gitee.com/xiao-ai-beimeng/beimeng/raw/master/img/202110251500359.png)

**标签： @[数组](https://leetcode-cn.com/tag/array/) @[回溯](https://leetcode-cn.com/tag/backtracking/)**

> 回溯法：
>
> ```java
> public List<List<Integer>> combine(int n, int k) {
>     List<List<Integer>> answer = new ArrayList<>();
>     trackBack(answer,new ArrayList<Integer>(),1,n,1,k);
>     return answer;
> }
> 
> public void trackBack(List<List<Integer>> answer,List<Integer> list,int begin,int n,int deep,int k){
> 
>     for(int i=begin;i<=n;i++){
>         list.add(i);
>         if(deep == k){
>             answer.add(new ArrayList<>(list));
>         }else
>             trackBack(answer,new ArrayList<Integer>(list),i+1,n,deep+1,k);
>         list.remove(list.size()-1);
>     }
> }
> ```
>
> 

