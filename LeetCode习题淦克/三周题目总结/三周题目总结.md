# 题目总结 - 🧷

> 整理习题答案，分析汇总

## 第一周 1|2|3|20|21|22

### [1. 两数之和](https://leetcode-cn.com/problems/two-sum/)

![image-20211008203109561](https://gitee.com/xiao-ai-beimeng/beimeng/raw/master/img/202110082031705.png)

**标签：@数组 @哈希表**

> 思路：在一个数组中寻找**两个**相加和为**目标值**的两个元素下标。
>
> 遍历每个元素，题中说明，只会有一种答案，所以只需要使用每次遍历到的元素，去找另一个元素，有则返回即可
>
> ```java
> public int[] twoSum(int[] nums, int target) {
>     for(int i=0;i<nums.length;i++){
>         for(int j=i+1;j<nums.length;j++){
>             if(target - nums[i] == nums[j])
>                 return new int[]{i,j};
>         }
>     }
> 
>     return null;
> }
> ```
>
> 对于这种遍历方式，时间复杂度为 O(n2)
>
> 优化的方式，使用**@哈希表**。
>
> ```java
> public int[] twoSum(int[] nums, int target) {
>     Map<Integer,Integer> map = new HashMap<>();
> 
>     for(int i=0;i<nums.length;i++){
>         // 现在集合中寻找
>         if(map.containsKey(target - nums[i])){
>             return new int[]{map.get(target - nums[i]),i}; // 先后顺序
>         }else{
>             map.put(nums[i],i);
>         }
>     }
> 
>     return null;
> }
> ```
>
> 

### [2. 两数相加](https://leetcode-cn.com/problems/add-two-numbers/)

![image-20211010194740235](https://gitee.com/xiao-ai-beimeng/beimeng/raw/master/img/202110101947382.png)

**相关标签：@[递归](https://leetcode-cn.com/tag/recursion/problemset/) @[链表](https://leetcode-cn.com/tag/linked-list/problemset/) @[数学](https://leetcode-cn.com/tag/math/problemset/) **

> 思路： 不要忘记进一
>
> ```java
> public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
>     return rrun(l1,l2,0);
> }
> 
> // 递归的方式解决问题
> public ListNode rrun(ListNode l1,ListNode l2, int point){ // 最后一位数表示进一
>     // 定义递归出口
>     if(l1 == null && l2 == null && point == 0)
>         return null;
>     int val = (l1!=null?l1.val:0) + (l2!=null?l2.val:0) + point;
>     int point2 = 0;
>     if(val >= 10){
>         point2 = val/10;
>         val %= 10;
>     }
> 
>     ListNode head = new ListNode(val);
>     head.next = rrun(l1!=null?l1.next:null,l2!=null?l2.next:null,point2);
> 
>     return head;
> }
> ```

### [3. 无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)

![image-20211010201637639](https://gitee.com/xiao-ai-beimeng/beimeng/raw/master/img/202110102016701.png)

**标签：@[哈希表](https://leetcode-cn.com/tag/hash-table/) @[字符串](https://leetcode-cn.com/tag/string/) @[滑动窗口](https://leetcode-cn.com/tag/sliding-window/)**

> 思路：滑动窗口 `滑动窗口问题其实就是枚举法的一种优化形式`
>
> ```java
> public int lengthOfLongestSubstring(String s) {
>  char[] chars = s.toCharArray();
>  String str = "";
>  int len = 0;
>  for(int i=0;i<chars.length;i++){
>      if(str.indexOf("" + chars[i]) == -1){
>          str += chars[i];
>      }else{// 去掉这个值以及之前的所有值
>          if(str.split("" + chars[i]).length >= 2){
>              str = str.split("" + chars[i])[1] + chars[i];
>          }else{
>              str = "" + chars[i];
>          }
>      }
>      if (str.length() > len)
>          len = str.length();
> 
>  }
>  return len;
> }
> ```
>
> **哈希表**
>
> 我们每次要去字符串中寻找一个和当前字符相等的字符的位置
>
> ```java
> public int lengthOfLongestSubstring(String s) {
>     Map<Character,Integer> map = new HashMap<>();
> 
>     int p1=-1,sum=0;
>     char[] chars = s.toCharArray();
>     for(int i=0;i<chars.length;i++){
>         if(map.containsKey(chars[i])&&map.get(chars[i])>=p1){
>             p1 = map.get(chars[i]);
>             map.replace(chars[i],i);
>         }else{
>             map.put(chars[i],i);
>         }
>         sum = Math.max(i-p1,sum);
>     }
> 
>     return sum;
> }
> ```
>
> **数组方式**
>
> ```java
> public int lengthOfLongestSubstring(String s) {
> if(s.length() <= 1)
> return s.length();
> 
> int[] last = new int[128];
> for(int i=0;i<last.length;i++){
> last[i] = -1;
> }
> int start = -1,res = 0;
> for(int i=0;i<s.length();i++){
> int index = s.charAt(i);
> start = Math.max(start,last[index]);
> res = Math.max(res,i-start);
> last[index] = i;
> }
> return res;
> }
> ```

### [20. 有效的括号](https://leetcode-cn.com/problems/valid-parentheses/)

![image-20211011081832439](https://gitee.com/xiao-ai-beimeng/beimeng/raw/master/img/202110110818574.png)

**标签：@[栈](https://leetcode-cn.com/tag/stack/) @[字符串](https://leetcode-cn.com/tag/string/)**

> 思路：使用一个栈
>
> 如果每次遍历的元素是右边的括号，判断栈顶元素和当前元素是否成对，否false 是则出栈，判断下一个
>
> ```java
> public boolean isValid(String s) {
>     Stack<Character> stack = new Stack<>();
>     for (int i = 0; i < s.length(); i++) {
>         char character = s.charAt(i);
>         if (character == ')' || character == '}' || character == ']'){
>             if (stack.isEmpty())
>                 return false; // 如果栈已经为空，直接结束
>             switch (stack.pop()){
>                 case '(':
>                     if (character != ')')
>                         return false;
>                     break;
>                 case '{':
>                     if (character != '}')
>                         return false;
>                     break;
>                 case '[':
>                     if (character != ']')
>                         return false;
>                     break;
>                 default:return false;
>             }
>         }else {
>             stack.push(character);
>         }
>     }
>     return stack.isEmpty();
> }
> ```

### [21. 合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists/)

![image-20211011082538719](https://gitee.com/xiao-ai-beimeng/beimeng/raw/master/img/202110110825802.png)

**标签：@[递归](https://leetcode-cn.com/tag/recursion/) @[链表](https://leetcode-cn.com/tag/linked-list/)**

> 思路：递归
>
> ```java
> public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
> 
>     return run(l1,l2);
> }
> 
> public ListNode run(ListNode l1, ListNode l2){
>     // 递归出口
>     if(l1==null && l2==null)
>         return null;
> 
>     ListNode head; 
>     if((l1!=null?l1.val:101) <= (l2!=null?l2.val:101)){
>         head = l1;
>         l1 = l1!=null?l1.next:null;
>     }else{
>         head = l2;
>         l2 = l2!=null?l2.next:null;
>     }
>     head.next = run(l1,l2);
>     return head;
> }
> ```

### [22. 括号生成](https://leetcode-cn.com/problems/generate-parentheses/)

![image-20211011083905183](https://gitee.com/xiao-ai-beimeng/beimeng/raw/master/img/202110110839245.png)

**标签：@[字符串](https://leetcode-cn.com/tag/string/) @[动态规划](https://leetcode-cn.com/tag/dynamic-programming/) @[回溯](https://leetcode-cn.com/tag/backtracking/)**

> **动态规划**： 找到递推规律即可
> 从题目中获得一个关键的递推式
> f(n) = (a)b a 和 b 的关系是a+b+1=n
> 由这个递推式即可想到动态规划
> 事先知道f(1) = "()"
> 使用一个二维集合保存
>
> ![image-20211011095312931](https://gitee.com/xiao-ai-beimeng/beimeng/raw/master/img/202110110953974.png)
>
> ```java
> List<List<String>> dp;
> public List<String> generateParenthesis(int n) {
>  dp = new ArrayList<>();
>  List<String> one = new ArrayList<>();
>  List<String> two = new ArrayList<>();
>  one.add("");
>  dp.add(one); // 保存f(0) 的值
> 
>  two.add("()");
>  dp.add(two); // 保存f(0) 的值
> 
>  for(int i=2;i<=n;i++){
>      dp.add(f(i));
>  }
>  dp.get(n).sort(new Comparator<String>() {
>      @Override
>      public int compare(String o1, String o2) {
>          int point = 0;
>          while ( point<=o1.length()-1 && o1.charAt(point) == o2.charAt(point)){
>              point++;
>          }
>          if (point > o1.length()-1)
>              return 0;
>          return Character.compare(o1.charAt(point), o2.charAt(point));
>      }
>  });
>  return dp.get(n);
> }
> 
> public List<String> f(int n){
>  //  System.out.print(dp);
>  List<String> ans = new ArrayList<>();
>  n-=1;
>  List<String> a;
>  List<String> b;
>  for(int i=0;i<=n;i++){
>      a = dp.get(n-i);
>      b = dp.get(i);
>      for(String stra:a){
>          for(String strb:b){
>              ans.add("(" + stra + ")" + strb);
>          }
>      }
>  }
>  return ans;
> }
> ```
>
> ![image-20211012155138796](https://gitee.com/xiao-ai-beimeng/beimeng/raw/master/img/202110121551883.png)
>
> **回溯法** 对暴力法的一种剪枝方法 【String 是非引用传递】
>
> ```java
> public List<String> generateParenthesis(int n) {
>     // 回溯法
>     List<String> ans = new ArrayList<>();
> 
>     f(ans,0,0,"",n);
> 
>     return ans;
> }
> 
> public void f(List<String> ans,int left,int right,String str,int n){
>     if(right > left)
>         return ;
>     if(left == right && right == n){
>         ans.add(str);
>         return;
>     }
>     if(left < n)
>         f(ans,left+1,right,str + "(",n);
> 
>     f(ans,left,right+1,str + ")",n);
> }
> ```
>

## 第二周 24|26|27|35|49

### [24. 两两交换链表中的节点](https://leetcode-cn.com/problems/swap-nodes-in-pairs/)

![image-20211011161735337](https://gitee.com/xiao-ai-beimeng/beimeng/raw/master/img/202110111617402.png)

**标签：@[递归](https://leetcode-cn.com/tag/recursion/) @[链表](https://leetcode-cn.com/tag/linked-list/)**

> ```java
> public ListNode swapPairs(ListNode head) {
>     // 保证两个节点
>     if(head==null || head.next==null)
>         return head;
>     ListNode p2 = head.next;
>     head.next = p2.next;
>     p2.next = head;
>     p2.next.next = swapPairs(p2.next.next);
>     return p2;
> }
> ```

### [26. 删除有序数组中的重复项](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/)

![image-20211011162427017](https://gitee.com/xiao-ai-beimeng/beimeng/raw/master/img/202110111624098.png)

**标签：@[数组](https://leetcode-cn.com/tag/array/) @[双指针](https://leetcode-cn.com/tag/two-pointers/)**

> 遍历数组，如果当前值和预定指针位置的值不想同(前提是已经升序排列，交换)
>
> ```java
> public int removeDuplicates(int[] nums) {
>     if(nums.length <= 1){
>         return nums.length;
>     }
>     int p = 0;
>     for(int j = 1;j<nums.length;j++){
>         if(nums[j] != nums[p]){
>             nums[++p] = nums[j];
>         }
>     }
> 
>     return p+1;
> }
> ```

### [27. 移除元素](https://leetcode-cn.com/problems/remove-element/)

![image-20211013102438427](https://gitee.com/xiao-ai-beimeng/beimeng/raw/master/img/202110131024523.png)

**标签: @[数组](https://leetcode-cn.com/tag/array/) @[双指针](https://leetcode-cn.com/tag/two-pointers/)**

> ```java
> public int removeElement(int[] nums, int val) {
>     //int pb = nums.length-1; // point a
>     int tmp;
>     int i=0;
>     for(int pb = nums.length-1;i<=pb;i++){
>         if(nums[pb] == val){
>             pb--;
>             i--;
>             continue;
>         }
>         if(nums[i] == val){
>             tmp = nums[i];
>             nums[i] = nums[pb];
>             nums[pb] = tmp;
>         }
>     }
>     return i;
> }
> ```
>
> 

### [35. 搜索插入位置](https://leetcode-cn.com/problems/search-insert-position/)

![image-20211013103822239](https://gitee.com/xiao-ai-beimeng/beimeng/raw/master/img/202110131038317.png)

**标签： @[数组](https://leetcode-cn.com/tag/array/) @[二分查找](https://leetcode-cn.com/tag/binary-search/)**

> ```java
> public int searchInsert(int[] nums, int target) {
>     if(target <= nums[0])
>         return 0;
>     if(target > nums[nums.length-1])
>         return nums.length;
>     int begin=0;
>     int end = nums.length-1;
>     int mid;
>     while(end - begin > 1){
>         mid = (end-begin)/2 + begin;
>         if(nums[mid] == target)
>             return mid;
>         if(nums[mid] < target)
>             begin = mid;
>         else
>             end = mid;
>     }
>     return end;
> }
> ```

### [49. 字母异位词分组](https://leetcode-cn.com/problems/group-anagrams/)

![image-20211013105336897](https://gitee.com/xiao-ai-beimeng/beimeng/raw/master/img/202110131053969.png)

**标签： @[哈希表](https://leetcode-cn.com/tag/hash-table/) @[字符串](https://leetcode-cn.com/tag/string/) @[排序](https://leetcode-cn.com/tag/sorting/)**

> ```java
> public List<List<String>> groupAnagrams(String[] strs) {
>     Map<String,List<String>> map = new HashMap<>();
> 
>     String sortStr;
>     for(int i=0;i<strs.length;i++){
>         sortStr = sort(strs[i]);
>         if(map.containsKey(sortStr)){
>             map.get(sortStr).add(strs[i]);
>         }
>         else{
>             List<String> list = new ArrayList<>();
>             list.add(strs[i]);
>             map.put(sortStr,list);
>         }
>     }
>     // List<List<String>> ans = new ArrayList<>();
>     // for(List<String> one : map.values()){
>     //     ans.add(one);
>     // }
>     return new ArrayList<List<String>>(map.values());
>     //return ans;
> }
> 
> public String sort(String str){
>     char[] chars = str.toCharArray();
>     Arrays.sort(chars);
>     return new String(chars);
> }
> ```

## 第三周  56|435|452|



### [56. 合并区间](https://leetcode-cn.com/problems/merge-intervals/)

![image-20211018080802635](https://gitee.com/xiao-ai-beimeng/beimeng/raw/master/img/202110180808704.png)

**标签：[数组](https://leetcode-cn.com/tag/array/) [排序](https://leetcode-cn.com/tag/sorting/)**

> 局部最优解-> 全局最优解
>
> ```java
> public int[][] merge(int[][] intervals) {
>      if(intervals.length <= 1)
>          return intervals;
>        Arrays.sort(intervals,(int[] o1,int[] o2)->{
>            return o1[0]!=o2[0]?o1[0]-o2[0]:o1[1]-o2[1];
>        });
>        List<int[]> list = new ArrayList<>();
>      int begin = intervals[0][0];
>     int end = intervals[0][1]; //结尾
>      for(int i=1;i<intervals.length;i++){
>          if(intervals[i][0] <= end){ // 满足合并条件
>             end = Math.max(end,intervals[i][1]);
>          }else{
>                list.add(new int[]{begin,end});
>                begin = intervals[i][0];
>                end = intervals[i][1];
>            }
>        }
>        list.add(new int[]{begin,end});
>    
>        return list.toArray(new int[list.size()][]);
>    }
>    ```
>    



### [435. 无重叠区间 ⭐](https://leetcode-cn.com/problems/non-overlapping-intervals/)

![image-20211013192201328](https://gitee.com/xiao-ai-beimeng/beimeng/raw/master/img/202110131922402.png)

**标签：@[贪心](https://leetcode-cn.com/tag/greedy/) @[数组](https://leetcode-cn.com/tag/array/) @[动态规划](https://leetcode-cn.com/tag/dynamic-programming/) @[排序](https://leetcode-cn.com/tag/sorting/)**

> **贪心算法**： 所有冲突的区间中我们只保留一个。所以这题就不像想象的那么难。
>
> ```java
> public int eraseOverlapIntervals(int[][] intervals) {
>      Arrays.sort(intervals,(int[] o1,int[] o2)->o1[0]-o2[0]); // 排序。
>      int end = intervals[0][1];
>        int ans = 1;
>        for(int i=0;i<intervals.length;i++){
>            if(intervals[i][0] >= end){
>                ans+=1;
>              end = intervals[i][1];
>          }else
>              end = Math.min(end,intervals[i][1]);
>      }
>      return intervals.length - ans;
>  }
>    ```
>    
>    **动态规划**：
>    
>    

### [452. 用最少数量的箭引爆气球](https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/)

![image-20211018080702558](https://gitee.com/xiao-ai-beimeng/beimeng/raw/master/img/202110180807693.png)

**标签：[贪心](https://leetcode-cn.com/tag/greedy/) [数组](https://leetcode-cn.com/tag/array/) [排序](https://leetcode-cn.com/tag/sorting/)**

> **贪心算法:**  java中int类型的取值范围是 【-2^31 - 2^31-1】但是在排序的过程中,2^31-1 减去 -2^31 会超出int的长度限制。排序的时候比较大小而不是做差可以避免这个问题。
>
> ```java
> public int findMinArrowShots(int[][] points) {
>     Arrays.sort(points,(int[] a,int[] b)->Integer.compare(a[0],b[0]));
>     int end = points[0][1];
>     int ans = 1;
>     for(int i=0;i<points.length;i++){
>         if(points[i][0] > end){
>             ++ans;
>             end = points[i][1];
>         }else
>             end = Math.min(end,points[i][1]);
>     }
>     return ans;
> }
> ```
>
> 



## 第四周  46|53|77|78|57

### [46. 全排列](https://leetcode-cn.com/problems/permutations/)

![image-20211018090614970](https://gitee.com/xiao-ai-beimeng/beimeng/raw/master/img/202110180906056.png)

**标签：[@数组](https://leetcode-cn.com/tag/array/) [@回溯](https://leetcode-cn.com/tag/backtracking/)**

> 探索所有可能，使用回溯算法剪枝 [Java遍历Map集合的四种方式](http://c.biancheng.net/view/6872.html)
>
> ```java
> public List<List<Integer>> permute(int[] nums) { // 使用回溯法
>     List<List<Integer>> list = new ArrayList<>();
>     backTrack(list,new ArrayList<Integer>(),nums);
>     return list;
> }
> 
> public void backTrack(List<List<Integer>> answer,List<Integer> tmp,int[] nums){
>     if(tmp.size() == nums.length){
>         answer.add(tmp);
>     }
> 
>     for(int i=0;i<nums.length;i++){
>         if(!tmp.contains(nums[i])){
>             tmp.add(nums[i]);
>             backTrack(answer,new ArrayList<Integer>(tmp),nums);
>             tmp.remove(tmp.size()-1);
>         }
>     }
> }
> ```
>
> 判断条件优化之后
>
> ```java
> public List<List<Integer>> permute(int[] nums) {// 使用回溯法
>     List<List<Integer>> list = new ArrayList<>();
>     Map<Integer,Boolean> flags = new HashMap<>();
>     for(int i=0;i<nums.length;i++)
>         flags.put(i,false);
>     backTrack(list,new ArrayList<Integer>(),flags,nums);
> 
>     return list;
> }
> 
> public void backTrack(List<List<Integer>> answer,List<Integer> tmp,Map<Integer,Boolean> flags,int[] nums){
>     if(tmp.size() == nums.length){
>         answer.add(tmp);
>     }
> 
>     for(int i=0;i<nums.length;i++){
>         if(!flags.get(i)){
>             flags.replace(i,true);
>             tmp.add(nums[i]);
>             backTrack(answer,new ArrayList<Integer>(tmp),flags,nums);
>             tmp.remove(tmp.size()-1);
>             flags.replace(i,false);
>         }
>     }
> }
> ```
>
> 

### [53. 最大子序和](https://leetcode-cn.com/problems/maximum-subarray/)

![image-20211019111931248](https://gitee.com/xiao-ai-beimeng/beimeng/raw/master/img/202110191436222.png)

**标签：@[数组](https://leetcode-cn.com/tag/array/) @[分治](https://leetcode-cn.com/tag/divide-and-conquer/) @[动态规划](https://leetcode-cn.com/tag/dynamic-programming/)**

> 动态规划：
>
> 每次判断前面和是不是负数。【`🙂】
>
> ```java
> public int maxSubArray(int[] nums) {
>     int dp = nums[0], answer = nums[0];
>     for(int i=1;i<nums.length;i++){
>         dp = Math.max(dp + nums[i],nums[i]);
>         answer = Math.max(answer,dp);
>     }
>     return answer;
> }
> ```
>
> 如果前面的和小于0，那么前面的数字再多也没有意义。

### [77. 组合](https://leetcode-cn.com/problems/combinations/)

![image-20211025150054260](https://gitee.com/xiao-ai-beimeng/beimeng/raw/master/img/202110251500359.png)

**标签： @[数组](https://leetcode-cn.com/tag/array/) @[回溯](https://leetcode-cn.com/tag/backtracking/)**

> 回溯法：
>
> ```java
> public List<List<Integer>> combine(int n, int k) {
>        List<List<Integer>> answer = new ArrayList<>();
>        backtrack(answer,new ArrayList<>(),n,k,1);
>        return answer;
> }
> 
> public void backtrack(List<List<Integer>> answer,List<Integer> list,int n,int k,int begin){
>     if(list.size() == k){
>            answer.add(new ArrayList<>(list));
>            return;
>        }
>        for(int i=begin;i<=n;i++){
>            list.add(i);
>            backtrack(answer,list,n,k,i+1);
>            list.remove(list.size()-1);
>        }
> }
> ```
>
> 

### [78. 子集](https://leetcode-cn.com/problems/subsets/)

![image-20211102204013632](https://gitee.com/xiao-ai-beimeng/beimeng/raw/master/img/202111022040771.png)

**标签 ：@[位运算](https://leetcode-cn.com/tag/bit-manipulation/) @[数组](https://leetcode-cn.com/tag/array/) @[回溯](https://leetcode-cn.com/tag/backtracking/) **

> ```java
> public List<List<Integer>> subsets(int[] nums) {
>     List<List<Integer>> answer = new ArrayList<>();
>     for(int k=0;k<=nums.length;k++){
>         backtrack(answer,new ArrayList<>(),k,0,nums);
>     }
>     return answer;
> }
> 
> public void backtrack(List<List<Integer>> answer,List<Integer> list,int k,int begin,int[] nums){
>     if(list.size() == k){
>         answer.add(new ArrayList<>(list));
>         return;
>     }
> 
>     for(int i=begin;i<nums.length;i++){
>         list.add(nums[i]);
>         backtrack(answer,list,k,i+1,nums);
>         list.remove(list.size()-1);
>     }
> }
> ```
>
> 但是实际上并不需要循环k，因为在77题的过程中他已经求出所有的子集了
>
> ```java
> public List<List<Integer>> subsets(int[] nums) {
>     List<List<Integer>> answer = new ArrayList<>();
>     backtrack(answer,new ArrayList<>(),nums.length,0,nums);
>     // for(int k=0;k<=nums.length;k++){
>     //     backtrack(answer,new ArrayList<>(),k,0,nums);
>     // }
>     return answer;
> }
> 
> public void backtrack(List<List<Integer>> answer,List<Integer> list,int k,int begin,int[] nums){
>     if(list.size() <= k){
>         answer.add(new ArrayList<>(list));
>     }else
>         return;
> 
>     for(int i=begin;i<nums.length;i++){
>         list.add(nums[i]);
>         backtrack(answer,list,k,i+1,nums);
>         list.remove(list.size()-1);
>     }
> }
> ```
>
> ![image-20211103132435117](https://gitee.com/xiao-ai-beimeng/beimeng/raw/master/img/202111031324618.png)

### [57. 插入区间](https://leetcode-cn.com/problems/insert-interval/)

![image-20211103132616954](https://gitee.com/xiao-ai-beimeng/beimeng/raw/master/img/202111031326844.png)

**标签： @[数组](https://leetcode-cn.com/tag/array/) **

> 没有什么方法
>
> ```java
> public int[][] insert(int[][] intervals, int[] newInterval) {
>     if(intervals.length == 0){
>         return new int[][]{newInterval};
>     }
>     List<int[]> answer = new ArrayList<>();
>     int begin = newInterval[0],end = newInterval[1];
>     for(int[] tmp:intervals){
>         if(tmp[1] < begin){
>             answer.add(tmp);
>         }else{
>             if(tmp[0] > end){
>                 answer.add(new int[]{begin,end});
>                 answer.add(tmp);
>                 begin = 10_0001;
>                 continue;
>             }
>             begin = Math.min(tmp[0],begin);
>             end = Math.max(tmp[1],end);
>         }
>     }
>     if(begin != 10_0001){
>         answer.add(new int[]{begin,end});
>     }
>     return answer.toArray(new int[answer.size()][]);
> }
> ```
>
> 
